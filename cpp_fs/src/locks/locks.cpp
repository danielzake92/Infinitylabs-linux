/*****************************************************************************
 *	FILENAME:	locks.cpp              AUTHOR: Daniel Zaken  LAB: RD100	 *
 *																			 *
 *	REVIEWER:																 *
 *																			 *
 *	PURPOSE:    Implementing for locks lib.							     *
 *																			 *
 *****************************************************************************/
#include "locks.hpp"
/*****************************************************************************/
namespace ilrd_rd100
{
    Mutex::Mutex()
    {
        m_lock = PTHREAD_MUTEX_INITIALIZER;
        pthread_mutex_init(&m_lock, NULL);
    }
/*****************************************************************************/
    void Mutex::Lock()
    {
        pthread_mutex_lock(&m_lock);
    }
/*****************************************************************************/
    void Mutex::Unlock()
    {
        pthread_mutex_unlock(&m_lock);
    }
/*****************************************************************************/
    boost::shared_ptr<pthread_mutex_t> Mutex::Get() 
    {
        boost::shared_ptr<pthread_mutex_t> mutex_ptr(&m_lock);
        return mutex_ptr;
    }
/*****************************************************************************/
    Mutex::~Mutex()
    {
        pthread_mutex_destroy(&m_lock);
    }
/*****************************************************************************/
/*****************************************************************************/

    Semaphore::Semaphore(unsigned int sem_size)
    {
        sem_init(&m_sem, 0, sem_size);
    }
/*****************************************************************************/
    void Semaphore::Wait()
    {
        sem_wait(&m_sem);
    }
/*****************************************************************************/
    void Semaphore::TryWait()
    {
        sem_trywait(&m_sem);
    }
/*****************************************************************************/
    void Semaphore::Post()
    {
        sem_post(&m_sem);
    }
/*****************************************************************************/
    Semaphore::~Semaphore()
    {
        sem_destroy(&m_sem);
    }
/*****************************************************************************/
/*****************************************************************************/
    Condition::Condition(Mutex &mutex) : m_mutex(mutex)
    {
        m_cond = PTHREAD_COND_INITIALIZER;
        pthread_cond_init(&m_cond, NULL);
    }
/*****************************************************************************/
    void Condition::Broadcast()
    {
        pthread_cond_broadcast(&m_cond);
    }
/*****************************************************************************/
    // void Condition::Wait()
    // {
    //     pthread_cond_wait(&m_cond, m_mutex);
    // }
/*****************************************************************************/
    Condition::~Condition()
    {
        pthread_cond_destroy(&m_cond);
    }
}
/*****************************************************************************/
/*****************************************************************************/
